<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600"
			   creationComplete="onCreationComplete(event)">
	<s:layout>
		<s:VerticalLayout/>
	</s:layout>
	<fx:Declarations>
		<!--  -->
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			
			import spark.events.IndexChangeEvent;
			
			private var streamPub:NetStream; //must declare outside, otherwise, gc will recycle it.
			private var streamViewA:NetStream; //must declare outside
			private var streamViewB:NetStream; //must declare outside
			
			private var connectionPub:NetConnection;			
			private var connectionSub:NetConnection;
			private var container:UIComponent;
			private var mic:Microphone;
			private var serverIp:String = "192.168.2.109";//"54.186.122.59";//"192.168.0.61";
			private var mixedStreamPrefix:String = "__mixed__";
			private var karaokeStream:String = "__mixed__karaoke";
			
			[Bindable]
			private var dataSet:ArrayCollection = new ArrayCollection(
				[   
					{value:"testliveA", code:"testliveA"},
					{value:"testliveB", code:"testliveB"}			
				]
			);
			
			[Bindable]
			private var songSet:ArrayCollection = new ArrayCollection(
				[   
					{value:"Please Pick A Song", code:"Please Pick A Song"},
					{value:"Yi Jian Mei", code:"Yi Jian Mei"},
					{value:"Cannot take my eyes off of you", code:"Cannot take my eyes off of you"},	
					{value:"Bella Ciao", code:"Bella Ciao"},	
					{value:"Let It Go", code:"Let It Go"},	
					{value:"Do You Want To Build A Snowman", code:"Do You Want To Build A Snowman"},	
					{value:"For the First Time in Forever", code:"For the First Time in Forever"},	
					{value:"Hong Dou", code:"Hong Dou"},	
					{value:"Neon Lights", code:"Neon Lights"},	
					{value:"Top of the world", code:"Top of the world"},
					{value:"Take back the night", code:"Take back the night"},
					{value:"Fallen Kingdom", code:"Fallen Kingdom"},	
					{value:"Lets have some fun in minecraft", code:"Lets have some fun in minecraft"},	
					{value:"Gregory", code:"Gregory"},	
					{value:"The Little Birch Tree", code:"The Little Birch Tree"},	
					{value:"It's a small world", code:"It's a small world"},	
					{value:"Rassa seya eh", code:"Rassa seya eh"},	
					{value:"Crazy colored creatures", code:"Crazy colored creatures"}	
				]
			);
			private var publishDest:String = null;
			private var publishedStreamArray:Vector.<String> = new Vector.<String>();
			
			private var videoWidth:int = 320;
			private var videoHeight:int = 240;
			private var positionArray:Array = [ [0, 0], [0, videoHeight]];
			
			public function onCreationComplete(event:FlexEvent) : void {
				var videoPath:String = "rtmp://"+serverIp+"/myRed5App/";
				// setup connection code
				connectionPub = new NetConnection();
				connectionPub.connect(videoPath);
				connectionPub.addEventListener(NetStatusEvent.NET_STATUS, onConnectionANetStatus);
				connectionPub.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				connectionPub.client = this;	
			}
			
			public function onConnectionANetStatus(event:NetStatusEvent) : void {
				// did we successfully connect
				if(event.info.code == "NetConnection.Connect.Success") {
					delayedFunctionCall(1000, function(e:Event):void {publishNow();});
					//Alert.show("NetConnection.Connect.Success!", "Information");
				} else {
					Alert.show("Unsuccessful Connection", "Information");
				}
			}
			
			private function onCameraStatus( evt:StatusEvent ):void {
				if (evt.code == "Camera.Muted"){
					Alert.show("Camera Access Has Been Denied!", "Information");
				}
				if (evt.code == "Camera.Unmuted"){
					//Alert.show("Camera Access Has Been Granted", "Information");
				}
			}
			private function onMicStatus(evt:StatusEvent):void {
				switch (evt.code) {
					case "Microphone.Unmuted":
						//Alert.show("Camera Access Has Been Granted!", "Information");
						break;
					case "Microphone.Muted":
						Alert.show("Camera Access Has Been Denied!", "Information");
						break;
				}
			}
			
			public function publishNow() : void {
				//already published, don't do anything.
				if( publishDest!=null) {
					return;
				}
				//find the publishDest
				for each(var item:Object in dataSet){
					var bFound:Boolean = false;
					var length:uint = publishedStreamArray.length;
					for ( var i:uint=0; i<length; i++ ) {
						//check if the stream is already published
						if (publishedStreamArray[ i ] == item.value ) {
							bFound = true;
							break;
						}
					}
					if( !bFound) {
						publishDest = item.value;
						break;
					}
				}
				
				// container ( IVisualElement ) for DisplayObjects
				container = new UIComponent();
				container.width = stage.width/2;
				container.height = stage.height/2;
				addElement( container );
				
				if( publishDest == null ) {
					Alert.show("Cannot only listen to karaoke, since the room is already full!", "Information");
					lbl.text = "Listen mode. Can't Pick Songs";
					karaokeStream += "_delayed"; //listen to the delayed stream
					subscribeStreams(); //only showing streams
					return;
				}
				var camera:Camera = Camera.getCamera();	     
				mic = Microphone.getMicrophone();
				camera.addEventListener(StatusEvent.STATUS, onCameraStatus) ;
				mic.addEventListener(StatusEvent.STATUS, onMicStatus);
				if (camera == null) {
					Security.showSettings(SecurityPanel.CAMERA) ;
				} else{
					camera.setMode(videoWidth*2, videoHeight*2, 30); //640*480 30 fps
					camera.setQuality(16384,0); //0% quality, 16kBytes/sec bw limitation
					
					streamPub = new NetStream(connectionPub);
					var h264settings:H264VideoStreamSettings = new H264VideoStreamSettings(); 
					h264settings.setProfileLevel(H264Profile.BASELINE, H264Level.LEVEL_1_2);
					streamPub.videoStreamSettings = h264settings; 
					streamPub.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
					streamPub.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
					streamPub.attachCamera(camera);
					streamPub.publish(publishDest, "live");
					
					var video:Video = new Video();
					video.attachCamera(camera) ;
					container.addChild(video);
					video.width = videoWidth;
					video.height = videoHeight;
					video.x = video.y = 0;
					video.visible = true;
					
					//mic.rate = 8;
					mic.setLoopBack(CheckBox(loopback).selected);
					mic.encodeQuality = 10; //best quality
					mic.codec = SoundCodec.SPEEX; 
					mic.framesPerPacket = 1; //20ms per frame, instead of 40ms per frame
					mic.setSilenceLevel(0,200);
					readVolume();
					streamPub.attachAudio(mic);
					//Alert.show("camera width="+camera.width);
				}
			}
			private function netStatusHandler(event:NetStatusEvent):void {
				switch (event.info.code) {
					case "NetStream.Play.StreamNotFound":
						Alert.show("Unable to locate video: " + publishDest, "Information");
						break;
					case "NetStream.Publish.Start":
						//Alert.show("Publisher starts here");
						subscribeStreams();
						break;
					case "NetStream.Play.Start":
					case "NetStream.Play.Reset":
					case "Netstream.Play.PublishNotify":
					case "Netstream.Play.UnpublishNotify":
					case "NetStream.Video.DimensionChange":
						break;
					default:
						status.text = event.info.code;
						//Alert.show("Unknown event: " + event.info.code, "Information");
						break;
				}
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				Alert.show("securityErrorHandler: " + event, "Information");
			}
			
			private function asyncErrorHandler(event:AsyncErrorEvent):void {
				// ignore AsyncErrorEvent events.
			}
			public function subscribeStreams():void {
				var videoPath:String = "rtmp://"+serverIp+"/myRed5App/";
				// setup connection code
				connectionSub = new NetConnection();
				connectionSub.connect(videoPath);  //subscribe to live video
				//connection.connect("rtmp://localhost/vod/"); existing flv file/mp4 files
				connectionSub.addEventListener(NetStatusEvent.NET_STATUS, onConnectionBNetStatus);
				connectionSub.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				connectionSub.client = this;
			}
			public function onConnectionBNetStatus(event:NetStatusEvent) : void {
				// did we successfully connect
				if(event.info.code == "NetConnection.Connect.Success") {
					//Alert.show("onConnectionBNetStatus: " + event, "Information");
					connectStreams();
				} else {
					Alert.show("Unsuccessful Connection", "Information");
					disconnectStreams();
				}
			}
			
			private function disconnectStreams():void {
				//TODO
			}	
			
			private function connectStreams():void {
				var posIndex:int = 1;
				if( publishDest == null) {
					streamViewA = new NetStream(connectionSub);
					var itemA:Object = dataSet.getItemAt(posIndex-1);
					connectStream(streamViewA, itemA.value, positionArray[posIndex-1][0], positionArray[posIndex-1][1], videoWidth, videoHeight);
					posIndex++;
					streamViewB = new NetStream(connectionSub);
					var itemB:Object = dataSet.getItemAt(posIndex-1);
					connectStream(streamViewB, itemB.value, positionArray[posIndex-1][0], positionArray[posIndex-1][1], videoWidth, videoHeight);
					posIndex++;
				} else {
					for each(var item:Object in dataSet){
						if( item.value != publishDest ) {
							var streamView:NetStream = new NetStream(connectionSub);
							connectStream(streamView, item.value, positionArray[posIndex][0], positionArray[posIndex][1], videoWidth, videoHeight);
							posIndex++;
						}
					}
				}
				// next is karaoke
				var streamKara:NetStream = new NetStream(connectionSub);
				connectStream(streamKara, karaokeStream, videoWidth, 0, videoWidth*2, videoHeight*2 );
				
				/*
				for (var i:int = 0; i < container.numChildren; i++)
				{
				var obj:Video = container.getChildAt(i) as Video;
				Alert.show(obj.x + " "+ obj.y + " "+obj.width + " "+obj.height + " "+ publishDest);
				}
				*/
			}
			
			private function connectStream(stream:NetStream, url:String, x:int, y:int, width:int, height:int):void {
				stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
				stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				stream.play(url);
				
				var video:Video = new Video();
				video.attachNetStream(stream);
				container.addChild(video);
				//video.opaqueBackground = 0x000000;
				video.width = width;
				video.height = height;
				video.x = x;
				video.y = y;
				video.visible = true;
			}
			private function songList_changeHandler(event:IndexChangeEvent):void	
			{
				if( publishDest != null && songList.selectedIndex != 0) {
					status.text = "Song selected="+songList.selectedItem.value;
					connectionPub.call("song.selectSong", null, songList.selectedItem.value);	
					songList.selectedIndex = 0;
				}
			}
			private function onLoopBack(evt:MouseEvent):void {
				if(CheckBox(evt.target).selected) {
					mic.setLoopBack(true);
				} else {
					mic.setLoopBack(false);
				}
			}
			//server call to client
			private function newStream(publishedStream:String):void {
				if( publishedStreamArray.indexOf(publishedStream) == -1 && 
					publishedStream.indexOf(mixedStreamPrefix) < 0 && 
					publishedStream != publishDest ){ 
					//Alert.show("A new connection "+publishedStream+" joined", "Information");
					publishedStreamArray.push(publishedStream);
				}
			}
			private function removeElementFromStringVector(element:String, vector:Vector.<String>):void {  
				if(vector.indexOf(element) > -1){  
					vector.splice(vector.indexOf(element), 1);  
					removeElementFromStringVector(element, vector);
					//Alert.show("An old connection "+element+" left", "Information");  
				} else {  
					return;  
				}  
			}  
			private function delayedFunctionCall(delay:int, func:Function):void {
				//trace('going to execute the function you passed me in', delay, 'milliseconds');
				var timer:Timer = new Timer(delay, 1);
				timer.addEventListener(TimerEvent.TIMER, func);
				timer.start();
			}
			
			public function initStreams(resp:Object):void {
				var streamListStr:String = String(resp);
				//Alert.show("initStreams = "+streamListStr, "Information"); 
				if( streamListStr != "") {
					var streamListArr:Array = streamListStr.split(",");
					var arrLen:int = streamListArr.length;
					for (var i:int = 0; i<arrLen; i++) {
						newStream(streamListArr[i]);
					}
				}
			}
			public function addStream(resp:Object):void {
				newStream(String(resp));
			}
			public function removeStream(resp:Object):void {
				removeElementFromStringVector(String(resp), publishedStreamArray);
			}
			
			public function songSelected(resp:Object):void	
			{
				var song:String = String(resp);
				if( song != null) {
					status.text = "Song playing="+song;
				}
			}
			
			// Event handler function to display the scroll location.
			private function readVolume():void {
				var volume:Number = volumeBar.value/volumeBar.maximum;
				var micTransform:SoundTransform = mic.soundTransform;
				status.text = "volume was set to be "+micTransform.volume+" will be set to "+volume;
				micTransform.volume = volume;
				mic.soundTransform = micTransform;
			}
			private function volumeScroll():void {
				readVolume();
			}
		]]>
	</fx:Script>
	
	<s:Group>
		<s:layout>
			<s:HorizontalLayout/>
		</s:layout>
		<s:Label id="lbl" width="100%" height="100%" fontSize="20" horizontalCenter="0"
				 paddingLeft="10" paddingRight="5" paddingTop="5" text="Karaoke With Friends"
				 verticalCenter="0"/>
		<s:DropDownList id="songList" width="200" height="25" change="songList_changeHandler(event)"
						dataProvider="{songSet}" labelField="value" selectedIndex="0"/>
		
		<s:Group>
			<s:layout>
				<s:VerticalLayout/>
			</s:layout>
			<s:HSlider id="volumeBar" width="191" height="12" maximum="10" minimum="0" value="5" change="volumeScroll();"/>
			<s:CheckBox id="loopback" height="17" label="Mic Loopback Adjust Volume"
						click="onLoopBack(event);" fontSize="14" selected="false"/>
		</s:Group>
		
		<s:Label id="statusText" width="65" height="26" fontSize="20" paddingLeft="5" paddingTop="5"
				 text="Status"/>
		<s:TextInput id="status" width="305" height="25" text=""/>	
	</s:Group>
</s:Application>
